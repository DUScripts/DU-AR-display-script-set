{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"system.print(\"---------------------------------------------------------------\")\nsystem.print(\"Welcome to use JAST, Jeronimo's Advanced Scripted Technologies!\")\n\nlocal function findConnectedSlots()\n    local slot = {}\n    for slotName in pairs(unit) do\n        slot = unit[slotName]\n        if type(slot)=='table' and unit[slotName].getClass ~= nil and slotName~='system' and slotName~='library' and slotName~='unit' and slotName~='export' then\n            --system.print(slot.getClass())\n            if string.sub(slot.getClass(),1,8) == \"CoreUnit\" then\n                core = slot\n                system.print(\"Core found\")\n            end\n            if string.sub(slot.getClass(),1,8) == \"Adjustor\" and slot.getTags() == \"Jero\" then\n                adjustor = slot\n                adjustorID = adjustor.getLocalId()\n                system.print(\"JASS tagged adjustor found\")\n            end\n        end\n    end\n    if core ~= nil and adjustor ~= nil then\n        system.print(\"Links initialisation complete\")\n    else\n        system.print(\"Links initialisation failed:\")\n        system.print(\"Please link programming board to an adjustor tagged JASS and the Core\")\n        unit.exit()\n    end\nend\nfindConnectedSlots()\n\n\nlocal Atlas = require \"atlas\"\nHelios = Atlas[0]\n\n\ndisplayImages = false --export: display planets images when stoping movements (press ALT to toggle)\nbaseSize = 0.8 --export: radius of the base in meter\nbaseScale = (500*200000)\nsvgColor = \"chartreuse\" --export: svg color using web color names\nringsCP = 32 --export: number of control points in rings(reduce for better performances)\n\n\nringAnim = {0,0.25,0.35,0.5,0.75}\n\nunit.hideWidget()\nsystem.showScreen(1)\n\nfunction stringDecode(String, Separator)\n    local list = {}\n    local Separator = Separator or ' '\n    for key in String:gmatch('[^'..Separator..']+') do\n        --system.print(key)\n        list[#list+1] = key\n    end\n    return list\nend\n\nlocal cos, sin, max, min = math.cos, math.sin, math.max, math.min\nfunction convertToWorldCoordinates(posString)\n    local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'\n    local posPattern = '::pos{' .. num .. ',' .. num .. ',' .. num .. ',' .. num ..  ',' .. num .. '}'\n    local systemId, bodyId, latitude, longitude, altitude = string.match(posString,posPattern)\n                    \n    systemId = tonumber(systemId)\n    bodyId = tonumber(bodyId)\n    latitude = tonumber(latitude)\n    longitude = tonumber(longitude)\n    altitude = tonumber(altitude)\n                    \n    if tonumber(bodyId) == 0 then\n        return latitude,longitude,altitude\n    end\n                    \n    latitude = 0.0174532925199 * max(min(latitude, 90), -90)\n    longitude = 0.0174532925199 * (longitude % 360)\n                    \n    local center, radius = Helios[bodyId].center, tonumber(Helios[bodyId].radius)\n    local xproj = cos(latitude)\n    local px, py, pz = center[1]+(radius+altitude) * xproj*cos(longitude),\n                        center[2]+(radius+altitude) * xproj*sin(longitude),\n                        center[3]+(radius+altitude) * sin(latitude)\n                                        \n    return px, py, pz\nend\n\nPOIS = \"::pos{0,0,13856549,7386341,-258459}|AEGIS Market|white|❉\" --export: list here \"::pos\" coordinates of your favorit POIS separated by a \";\"(example: ::pos{0,0,x,y,z}|name|color|icon;)\nasteroids = \"::pos{0,0,2327507.9226,-4135530.0609,-7792895.3596};::pos{0,0,49675076.3333,29483758.3401,53707481.8602}\" --export: list here \"::pos\" coordinates of desired asteroids separated by a \";\"\nasteroidsColor = \"gold\" --export: asteroids icons color using web colors names\n\n--➀➁➂➃➄➅➆➇➈➉\n--➊➋➌➍➎➏➐➑➒➓\n--Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ  Ⓨ  Ⓩ\n--▲◣◢◥▼△▽⊿◤◥△▴▵▶▷▸▹►▻▼▽▾▿◀◁◂◃◄◅\n--♚ ♛ ♜ ♝ ♞ ♟\n--♔ ♕ ♖ ♗ ♘ ♙\n--☚ ☛ ☜ ☝ ☞ ☟\n--☩ ☨ ☦ ✙ ✚ ✛ ✜ ✝ ✞ ✠\n--✦ ★ ☆ ✰ ✮ ✯ ❇ ❈ ❅ ❄ ❆ ╰☆╮ ❉ ۞ \n--❃ ❀ ✿ ❁ ✾\n--♪ ♫ ♩ ♬ ♭ ♮ ♯\n--☼ ☀ ☁ ☂ ☃ ☄ ☾ ☽ ❄ ๑ ☠ ☭ ☄ ♆ ✌ ☢ ☣ ☮ ☯\n--☯ ✡ ☨ ✞ ✝ ☮ ☥ ☦ ☧ ☩ ☪ ☫ ☬ ☭  卐\n--♋ ♂ ♀ ☿ ❤ ❥ 웃 유 ♡\n--☹ ☺ ☻ ✓ ✔ ✕ ✖ ◧ ◨ ◩ ◪ ◫ ◬ ◭ ◮ ◯ ◰ ◱ ◲ ◳ ◴ ◵ ◶ ◷ ◸ ◹ ◺ ◻ ◼ ◽ ◾ ◿\n--┌ ┍ ┎ ┏ ┐ ┑ ┒ ┓ └ ┕ ┖ ┗ ┘ ┙ ┚ ┛ ├ ┝ ┞ ┟ ┠ ┡ ┢ ┣ ┤ ┥ ┦ ┧ ┨ ┩ ┪ ┫ ┬ ┭ ┮ ┯ ┰ ┱ ┲ ┳ ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻ ┼ ┽ ┾ ┿ ╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╌ ╍ ╎ ╏ ═ ║ ╒ ╓ ╔ ╕ ╖ ╗ ╘ ╙ ╚ ╛ ╜ ╝ ╞ ╟ ╠ ╡ ╢ ╣ ╤ ╥ ╦ ╧ ╨ ╩ ╪ ╫ ╬\n--❃ ❂ ○ ◎ ● ◯ ◕ ◔ ◐ ◑ ☢ ⊗ ⊙ ◘ ◙ ▤▥▦▧▨▩ ♤ ♧ ♡ ⊙ ✪ ✲\n--← ↑ → ↓ ↔ ↕ ↖ ↗ ↘ ↙ ↚ ↛ ↜ ↝ ↞ ↟ ↠ ↡ ↢ ↣ ↤ ↥ ↦ ↧ ↨ ⇎ ⇏ ⇐ ⇑ ⇒ ⇓ ⇔ \n\nPOISMarkers = {}\nlocal tempPOISMarkers = stringDecode(POIS, \";\")\nfor i, v in ipairs(tempPOISMarkers) do\n    POISMarkers[i] = stringDecode(v, \"|\")\n    POISMarkers[i][1] = {convertToWorldCoordinates(POISMarkers[i][1])}\nend\nsystem.print(\"POIs loaded: \"..#tempPOISMarkers..\" markers\")\ntempPOISMarkers = nil    \n\nasteroidsMarkers = stringDecode(asteroids, \";\")\nfor i, v in ipairs(asteroidsMarkers) do\n    asteroidsMarkers[i] = {convertToWorldCoordinates(v)}\nend\nsystem.print(\"Asteroids loaded: \"..#asteroidsMarkers..\" markers\")\n\nHelios = {}    \nfor k, v in pairs(Atlas[0]) do\n    Helios[#Helios+1] = v\nend\nsystem.print(\"Atlas loaded: \"..#Helios..\" bodies\")\nAtlas = nil\n\nsystem.print(\"Initialisation succesfull, check lua external parameters for more options!\")\nsystem.print(\"---------------------------------------------------------------\")","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"local sqrt, tan, rad, atan, cos, sin, format, concat, sort = math.sqrt, math.tan, math.rad, math.atan, math.cos, math.sin, string.format, table.concat, table.sort\nlocal MDX = system.getMouseDeltaX()*1.5\nlocal MDY = system.getMouseDeltaY()*1.5\nlocal pV = player.getVelocity()\nlocal pWP = player.getWorldPosition()\n--system.print(concat(pV))\nlocal function vectorLen(x,y,z)\n    return sqrt(x * x + y * y + z * z)\nend\n\nif MDX ~= 0 or MDY ~= 0 or vectorLen(pV[1],pV[2],pV[3]) > 0.1 or displayImages == false then\n\nlocal sw = system.getScreenWidth()\nlocal sh = system.getScreenHeight()\nlocal vFov = system.getCameraVerticalFov()\nlocal hFov = system.getCameraHorizontalFov()\nlocal near = 0.1\nlocal far = 100000000.0\nlocal aspectRatio = sh/sw\nlocal tanFov = 1.0/tan(rad(vFov)*0.5)\nlocal field = -far/(far-near)\nlocal af = aspectRatio*tanFov\nlocal nq = near*field\nlocal camPv3 = vec3(system.getCameraPos())\nlocal camWP = system.getCameraWorldPos()\nlocal camWPv3 = vec3(camWP)\nlocal camWPx, camWPy, camWPz = camWP[1], camWP[2], camWP[3]\nlocal camWF = system.getCameraWorldForward()\nlocal camWFv3 = vec3(camWF)\nlocal camWFx, camWFy, camWFz = camWF[1], camWF[2], camWF[3]\nlocal camWR = system.getCameraWorldRight()\nlocal camWRx, camWRy, camWRz = camWR[1], camWR[2], camWR[3]\nlocal camWU = system.getCameraWorldUp()\nlocal camWUx, camWUy, camWUz = camWU[1], camWU[2], camWU[3]\n\nlocal cWP = construct.getWorldPosition()\n--local cWPv3 = vec3(core.getConstructWorldPos())\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\nlocal mPP = player.getPosition()\nlocal mPPx, mPPy = mPP[1], mPP[2]\n\nlocal posX, posY, posZ = 0, 0, 0\nlocal vx, vy, vz = 0, 0, 0\nlocal sx, sy, sz = 0, 0, 0\nlocal sPX, sPY = 0\nlocal dist = 0\n\nlocal function local2World(vx,vy,vz)\n    x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n    y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n    z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n    return x,y,z\nend        \n    \nlocal function projection2D()\n    -- matrix resolution\n    vx = posX * camWRx + posY * camWRy + posZ * camWRz\n    vy = posX * camWFx + posY * camWFy + posZ * camWFz\n    vz = posX * camWUx + posY * camWUy + posZ * camWUz\n    -- 2D projection\n    sx = (af * vx)/vy\n    sy = ( -tanFov * vz)/vy\n    sz = ( -field * vy + nq)/vy\n    sPX, sPY = (sx+1)*sw*0.5, (sy+1)*sh*0.5 -- screen pos X Y\n    dist = sqrt(posX*posX + posY*posY + posZ*posZ) -- distance from camera to pos\nend\n\n\nlocal offsetX,offsetY,offsetZ = 0,0,0\nlocal adjPos = core.getElementPositionById(adjustorID) -- translation of adjustor local coords in world coords\nlocal vx,vy,vz = adjPos[1], adjPos[2], adjPos[3]+baseSize+0.5\noffsetX = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\noffsetY = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\noffsetZ = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n\nlocal SVG = [[\n<style>\n    .labelWhite {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: white;}\n    .labelYellow {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: gold;}\n    .labelRed {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: red;}  \n    .label {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: white;} \n    .hud {text-anchor: start; font-family: Play; alignment-baseline: middle; stroke-width: 2; fill: red;}\n    .text {stroke-width:10; stroke:red; fill:none; stroke-linecap:round; stroke-linejoin:round}\n    .middle {stroke-width:5; stroke:red; fill:none; stroke-linecap:round; stroke-linejoin:round}\n</style>]]\nlocal icones = \"\"\n\nlocal pCx, pCy, pCz = 0,0,0\nlocal pName = \"\"\nlocal pRadius = 0\n--local size = 15\nlocal dist_str = 0\nlocal big = 75\nlocal little = 14\nlocal pSize = 0\n  \nsort(Helios,function(a,b) return \n                vectorLen((a.center[1]/baseScale) * baseSize + offsetX - camWPx,\n                (a.center[2]/baseScale) * baseSize + offsetY - camWPy,\n                (a.center[3]/baseScale) * baseSize + offsetZ - camWPz)*10000 \n                > vectorLen((b.center[1]/baseScale) * baseSize + offsetX - camWPx,\n                (b.center[2]/baseScale) * baseSize + offsetY - camWPy,\n                (b.center[3]/baseScale) * baseSize + offsetZ - camWPz)*10000  \n                end)\n    \nfor i, entry in ipairs(Helios) do\n    --system.print(i)\n    pCx, pCy, pCz = Helios[i].center[1], Helios[i].center[2], Helios[i].center[3]\n    pName = Helios[i].name[1]\n    pRadius = Helios[i].radius ~= nil and Helios[i].radius or 500\n  \n    posX = (pCx / baseScale) * baseSize + offsetX - camWPx\n    posY = (pCy / baseScale) * baseSize + offsetY - camWPy\n    posZ = (pCz / baseScale) * baseSize + offsetZ - camWPz\n    projection2D()\n    --system.print(dist)\n    if sz < 1 and sPX > 0 and sPX < sw and sPY > 0  and sPY < sh then\n        --system.print(pName)\n        local size = atan(pRadius/2000000, dist) * (sw / tan(rad(hFov * 0.5)))*baseSize/1.5\n        pSize = size * 5\n        --if pName == \"Thades\" then pSize = size * 5 end\n        if displayImages == true then\n            icones = icones .. [[<SPAN style=\"position:fixed; left:]]..sPX - pSize/2 ..[[px; top:]]..sPY - pSize/2 ..[[px; filter: contrast(95%) brightness(150%);\">\n            <img src=\"]]..Helios[i].iconPath..[[\" style=\"width:]]..pSize ..[[px; height:]]..pSize ..[[px;opacity:0.85\">\n            </SPAN>]]\n        end\n        if entry.type[1] ~= 'Moon' and entry.type[1] ~= 'Asteroid' then \n            big = 75*(baseSize/1.5)   \n            SVG = SVG .. [[<circle cx=\"]]..sPX-MDX..[[\" cy=\"]]..sPY-MDY..[[\" r=\"]]..size..[[\" stroke=\"]]..svgColor..[[\" stroke-width=\"0.5\" fill=\"white\" fill-opacity=\"0.2\"/>]]\n            local offset = baseSize/1.5\n            local fop = 1\n            \n            SVG = SVG..[[<text x=\"]]..sPX-MDX..[[\" y=\"]]..sPY-MDY+offset..[[\" style=\"fill:]]..svgColor..[[; text-anchor: middle; font-family: Play; fill-opacity:]]..fop..[[\">\n                        <tspan x=\"]]..sPX-MDX..[[\" dy=\"]]..size + big/dist..[[\" style=\"font-size: ]]..big/dist..[[; fill-opacity:]]..fop..[[\">]]..pName..[[</tspan>\n                       </text>]]\n        else\n            SVG = SVG .. [[<circle cx=\"]]..sPX-MDX..[[\" cy=\"]]..sPY-MDY..[[\" r=\"]].. size/2 ..[[\" stroke=\"]]..svgColor..[[\" stroke-width=\"2\" fill=\"white\" fill-opacity=\"0.2\"/>]]\n        end\n    end\nend\n\n\n\nsort(asteroidsMarkers,function(a,b) return \n                vectorLen((a[1]/baseScale) * baseSize + offsetX - camWPx,\n                (a[2]/baseScale) * baseSize + offsetY - camWPy,\n                (a[3]/baseScale) * baseSize + offsetZ - camWPz)\n                > vectorLen((b[1]/baseScale) * baseSize + offsetX - camWPx,\n                (b[2]/baseScale) * baseSize + offsetY - camWPy,\n                (b[3]/baseScale) * baseSize + offsetZ - camWPz) \n                end)    \n    \nlocal SVG2 = \"\"\n\nfor i, entry in ipairs(asteroidsMarkers) do\n    --system.print(i)\n    pCx, pCy, pCz = entry[1], entry[2], entry[3]    \n    --system.print(pCx)\n    posX = (pCx / baseScale) * baseSize + offsetX - camWPx\n    posY = (pCy / baseScale) * baseSize + offsetY - camWPy\n    posZ = (pCz / baseScale) * baseSize + offsetZ - camWPz\n    projection2D()\n    --system.print(dist)\n    if sz < 1 and sPX > 0 and sPX < sw and sPY > 0  and sPY < sh then\n        --system.print(pName)\n        big = 75*(baseSize/1.5)   \n        local offset = baseSize/1.5\n        local fop = 1\n            \n        SVG2 = SVG2..[[<text x=\"]]..sPX-MDX..[[\" y=\"]]..sPY-MDY+offset..[[\" style=\"fill:]]..asteroidsColor..[[; text-anchor: middle; font-family: Play; fill-opacity:]]..fop..[[\">\n                     <tspan x=\"]]..sPX-MDX..[[\" dy=\"]].. 0 ..[[\" style=\"font-size: ]]..big/dist..[[; fill-opacity:]]..fop..[[\">☭</tspan>\n                     </text>]]\n    end --\nend    \n\n\nlocal markerName = \"POI\"\nlocal markerColor = \"white\"\nlocal markerIcon = \"✪\"    \n    \nsort(POISMarkers,function(a,b) return \n                vectorLen((a[1][1]/baseScale) * baseSize + offsetX - camWPx,\n                (a[1][2]/baseScale) * baseSize + offsetY - camWPy,\n                (a[1][3]/baseScale) * baseSize + offsetZ - camWPz)\n                > vectorLen((b.center[1]/baseScale) * baseSize + offsetX - camWPx,\n                (b[1][2]/baseScale) * baseSize + offsetY - camWPy,\n                (b[1][3]/baseScale) * baseSize + offsetZ - camWPz) \n                end)   \n    \nfor i, entry in ipairs(POISMarkers) do\n    --system.print(i)\n    pCx, pCy, pCz = POISMarkers[i][1][1], POISMarkers[i][1][2], POISMarkers[i][1][3]\n    markerName = POISMarkers[i][2]~=nil and POISMarkers[i][2] or \"POI\"\n    markerColor = POISMarkers[i][3]~=nil and POISMarkers[i][3] or \"white\"     \n    markerIcon = POISMarkers[i][4]~=nil and POISMarkers[i][4] or \"✪\"\n       \n  \n    posX = (pCx / baseScale) * baseSize + offsetX - camWPx\n    posY = (pCy / baseScale) * baseSize + offsetY - camWPy\n    posZ = (pCz / baseScale) * baseSize + offsetZ - camWPz\n    projection2D()\n    --system.print(dist)\n    if sz < 1 and sPX > 0 and sPX < sw and sPY > 0  and sPY < sh then\n        --system.print(pName)\n        big = 75*(baseSize/1.5)   \n        local offset = baseSize/1.5\n        local fop = 1\n            \n        SVG2 = SVG2..[[<text x=\"]]..sPX-MDX..[[\" y=\"]]..sPY-MDY+offset..[[\" style=\"fill:]]..markerColor..[[; text-anchor: middle; font-family: Play; fill-opacity:]]..fop..[[\">\n                     <tspan x=\"]]..sPX-MDX..[[\" dy=\"]].. 0 ..[[\" style=\"font-size: ]]..big/dist..[[; fill-opacity:]]..fop..[[\">]]..markerIcon..[[</tspan>\n                     <tspan x=\"]]..sPX-MDX..[[\" dy=\"]].. big/dist-5 ..[[\" style=\"font-size: ]]..(big/dist)/2 ..[[; fill-opacity:]]..fop..[[\">]]..markerName..[[</tspan>\n                     </text>]]\n    end\nend\n    \nposX = (cWPx / baseScale) * baseSize + offsetX - camWPx\nposY = (cWPy / baseScale) * baseSize + offsetY - camWPy\nposZ = (cWPz / baseScale) * baseSize + offsetZ - camWPz\nprojection2D()\n--system.print(dist)\nif sz < 1 and sPX > 0 and sPX < sw and sPY > 0  and sPY < sh then\n    --system.print(pName)\n    big = 100*(baseSize/1.5)   \n    local offset = baseSize/1.5\n    local fop = 1\n            \n    SVG2 = SVG2..[[<text x=\"]]..sPX-MDX..[[\" y=\"]]..sPY-MDY+offset..[[\" style=\"fill:red; text-anchor: middle; font-family: Play; fill-opacity:]]..fop..[[\">\n                     <tspan x=\"]]..sPX-MDX..[[\" dy=\"]].. 0 ..[[\" style=\"font-size: ]]..big/dist..[[; fill-opacity:]]..fop..[[\">⇓</tspan>\n                     <tspan x=\"]]..sPX-MDX..[[\" dy=\"]].. big/dist-5 ..[[\" style=\"font-size: ]]..(big/dist)/2 ..[[; fill-opacity:]]..fop..[[\">ME</tspan>\n                     </text>]]\nend    \n    \nlocal function rotateVec(vx, vy, vz, phi, ax, ay, az) --rotation of unpacked vec : vector to rotate / rotation angle in rad / axis vector\n    local l = sqrt(ax*ax + ay*ay + az*az)\n    local ux, uy, uz = ax/l, ay/l, az/l\n    local c, s = cos(phi), sin(phi)\n    local m1x, m1y, m1z = (c + ux * ux * (1-c)), (ux * uy * (1-c) - uz * s), (ux * uz * (1-c) + uy * s)\n    local m2x, m2y, m2z = (uy * ux * (1-c) + uz * s), (c + uy * uy * (1-c)), (uy * uz * (1-c) - ux * s)\n    local m3x, m3y, m3z = (uz * ux * (1-c) - uy * s), (uz * uy * (1-c) + ux * s), (c + uz * uz * (1-c))\n    return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz\nend\n    \n\n    \nlocal adjPosX, adjPosY, adjPosZ = adjPos[1], adjPos[2], adjPos[3]    \nlocal eUp = core.getElementUpById(adjustorID)\nlocal eWUpx, eWUpy, eWUpz = local2World(eUp[1]+adjPosX, eUp[2]+adjPosY, eUp[3]+adjPosZ)   \nlocal eFor = core.getElementForwardById(adjustorID)\nlocal eWForx, eWFory, eWForz = local2World(eFor[1]+adjPosX, eFor[2]+adjPosY, eFor[3]+adjPosZ)     \nlocal eRight = core.getElementRightById(adjustorID)\nlocal eWRightx, eWRighty, eWRightz = local2World(eRight[1]+adjPosX, eRight[2]+adjPosY, eRight[3]+adjPosZ)    \n\n-- ADJUSTORS AXIS    \n--posX = eWUpx - camWPx --+ offsetX\n--posY = eWUpy - camWPy --+ offsetY\n--posZ = eWUpz - camWPz --+ offsetZ\n--projection2D()    \n--SVG = SVG .. [[<text x=\"]]..sPX..[[\" y=\"]]..sPY..[[\" font-size=\"20\" text-anchor=\"middle\" font-family=\"Play\" alignment-baseline=\"middle\" fill=\"skyblue\">up</text>]]  \n--posX = eWForx - camWPx --+ offsetX\n--posY = eWFory - camWPy --+ offsetY\n--posZ = eWForz - camWPz --+ offsetZ\n--projection2D()    \n--SVG = SVG .. [[<text x=\"]]..sPX..[[\" y=\"]]..sPY..[[\" font-size=\"20\" text-anchor=\"middle\" font-family=\"Play\" alignment-baseline=\"middle\" fill=\"skyblue\">for</text>]]\n--posX = eWRightx - camWPx --+ offsetX\n--posY = eWRighty - camWPy --+ offsetY\n--posZ = eWRightz - camWPz --+ offsetZ\n--projection2D()    \n--SVG = SVG .. [[<text x=\"]]..sPX..[[\" y=\"]]..sPY..[[\" font-size=\"20\" text-anchor=\"middle\" font-family=\"Play\" alignment-baseline=\"middle\" fill=\"skyblue\">right</text>]]\nfor i, v in ipairs(ringAnim) do\n    ringAnim[i]=ringAnim[i] < baseSize-0.2 and ringAnim[i] + 0.01 or 0.001        \nend\nlocal animatedRings = {}\nlocal nCP = ringsCP    \nlocal rH = 0\nfor i, v in ipairs(ringAnim) do\n    animatedRings[i]={}\n    for l=0,nCP,1 do\n        --rings[i][l]={}\n        local nPx, nPy, nPz = rotateVec(eUp[1]*ringAnim[i]-eFor[1]*rH, eUp[2]*ringAnim[i]-eFor[2]*rH, eUp[3]*ringAnim[i]-eFor[3]*rH, rad((360/nCP)*l), eFor[1], eFor[2], eFor[3])\n        nPx, nPy, nPz = local2World(nPx+adjPosX, nPy+adjPosY, nPz+adjPosZ)\n        animatedRings[i][l+1]={nPx, nPy, nPz}\n    end\nend    \n\nlocal svgOut = false\n    \nfor i, v in ipairs(animatedRings) do\n    svgOut = false    \n    local tempSVG = [[<polyline class=\"frame]]..i..[[\" points=\"]]\n    for i2, v2 in ipairs(v) do\n        --svgOut = false\n        posX = v2[1] - camWPx --+ offsetX\n        posY = v2[2] - camWPy --+ offsetY\n        posZ = v2[3] - camWPz --+ offsetZ\n        projection2D()\n        tempSVG = tempSVG .. sPX - MDX .. \",\" .. sPY - MDY .. \" \"\n        if sz > 1 and sPX < 0 and sPX > sw and sPY < 0  and sPY > sh then svgOut = true end\n    end    \n    tempSVG = tempSVG .. [[\"/>]]\n    \n    if svgOut == false then\n        SVG = SVG..[[\n        <style>\n        .frame]]..i..[[ {stroke-width:]].. 1 / dist * 10 ..[[; stroke: ]]..svgColor..[[; fill: none; fill-opacity: 0.1; stroke-opacity: 0.3; stroke-linecap:round; stroke-linejoin:round}\n        </style>]]\n        SVG = SVG .. tempSVG\n    end \nend\n\nlocal rings = {{},{},{},{},{},{}}\nfor l=0,nCP,1 do    \n    local nPx, nPy, nPz = rotateVec(0, 0, baseSize, rad((360/nCP)*l), 1, 0, 0)\n    nPx, nPy, nPz = nPx+offsetX, nPy+offsetY, nPz+offsetZ\n    rings[1][l+1]={nPx, nPy, nPz}\n        \n    nPx, nPy, nPz = rotateVec(0, baseSize, 0, rad((360/nCP)*l), 0, 0, 1)\n    nPx, nPy, nPz = nPx+offsetX, nPy+offsetY, nPz+offsetZ\n    rings[2][l+1]={nPx, nPy, nPz}\n        \n    nPx, nPy, nPz = rotateVec(baseSize, 0, 0, rad((360/nCP)*l), 0, 1, 0)\n    nPx, nPy, nPz = nPx+offsetX, nPy+offsetY, nPz+offsetZ\n    rings[3][l+1]={nPx, nPy, nPz}\n    nPx, nPy, nPz = rotateVec((baseSize/4)*1, 0, 0, rad((360/nCP)*l), 0, 1, 0)\n    nPx, nPy, nPz = nPx+offsetX, nPy+offsetY, nPz+offsetZ\n    rings[4][l+1]={nPx, nPy, nPz}\n    nPx, nPy, nPz = rotateVec((baseSize/4)*2, 0, 0, rad((360/nCP)*l), 0, 1, 0)\n    nPx, nPy, nPz = nPx+offsetX, nPy+offsetY, nPz+offsetZ\n    rings[5][l+1]={nPx, nPy, nPz}\n    nPx, nPy, nPz = rotateVec((baseSize/4)*3, 0, 0, rad((360/nCP)*l), 0, 1, 0)\n    nPx, nPy, nPz = nPx+offsetX, nPy+offsetY, nPz+offsetZ\n    rings[6][l+1]={nPx, nPy, nPz}\nend    \n    \n    \nfor i, v in ipairs(rings) do\n    svgOut = false    \n    local tempSVG = [[<polyline class=\"frame]]..i+#animatedRings..[[\" points=\"]]\n    for i2, v2 in ipairs(v) do\n        --svgOut = false\n        posX = v2[1] - camWPx --+ offsetX\n        posY = v2[2] - camWPy --+ offsetY\n        posZ = v2[3] - camWPz --+ offsetZ\n        projection2D()\n        tempSVG = tempSVG .. sPX - MDX .. \",\" .. sPY - MDY .. \" \"\n        if sz > 1 and sPX < 0 and sPX > sw and sPY < 0  and sPY > sh then svgOut = true end\n    end    \n    tempSVG = tempSVG .. [[\"/>]]\n    \n    if svgOut == false then\n        SVG = SVG..[[\n        <style>\n        .frame]]..i+#animatedRings..[[ {stroke-width:]].. 1 / dist * 8 ..[[; stroke: white; fill: none; fill-opacity: 0.1; stroke-opacity: 0.3; stroke-linecap:round; stroke-linejoin:round}\n        </style>]]\n        SVG = SVG .. tempSVG\n    end \nend    \n    \n    \nlocal html = [[\n<style>\nsvg {\nposition:absolute;\ntop:0px;\nleft:0px;\n}\n</style>\n<div>\n<svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\">\n]].. SVG ..[[\n</svg>\n]].. icones ..[[\n<svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\">\n]].. SVG2 ..[[\n</svg>  \n</div>\n]]\n\nsystem.setScreen(html)\n--system.print(\"update\")\n\nelse --system.print(\"freeze\")\nend\n","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"1"},{"code":"displayImages = not displayImages","filter":{"args":[{"value":"lalt"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"2"}],"methods":[],"events":[]}