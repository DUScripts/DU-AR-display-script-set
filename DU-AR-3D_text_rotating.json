{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"textInput = {text = \"JASS ADVANCED SOLAR SYSTEM|ships and bases decoration||press alt to display planets icons\", \n--textInput = {text = \"oo oo|oo\", \n    alignment = \"middle\", --left / middle / right\n    baseline = \"top\", --top / middle / bottom\n    height = 0.07, --height in meter\n    color = \"orange\", --color in named webcolor\n    stroke = 6, --stroke width\n    spacing = {x = 0.02, y = 0.05}, --spacing between letters and lines\n    offset = {x = 0, y = 0.5}, --additionnal offset from origine point in meters\n    rotation = {x = 0, y = 0, z = 0} --wip\n}\n\ncore = {}\nadjustor = {}\nadjustorID = 0\n\nlocal function findConnectedSlots()\n    local slot = {}\n    for slotName in pairs(unit) do\n        slot = unit[slotName]\n        if type(slot)=='table' and unit[slotName].getClass ~= nil and slotName~='system' and slotName~='library' and slotName~='unit' and slotName~='export' then\n            system.print(slot.getClass())\n            if string.sub(slot.getClass(),1,8) == \"CoreUnit\" then\n                core = slot\n                --system.print(\"Core found\")\n            end\n            if string.sub(slot.getClass(),1,8) == \"Adjustor\" then\n                adjustor = slot\n                adjustorID = adjustor.getLocalId()\n                --system.print(\"Adjustor found\")\n            end\n        end\n    end\nend\nfindConnectedSlots()\nlocal adjPos = core.getElementPositionById(adjustorID)\nadjustorPos = {x=adjPos[1] ,y=adjPos[2] ,z=adjPos[3] }\n\nalphaNum = {\nA = {{0,4},{0,0},{2,0},{2,4},{2,2},{0,2}},\nB = {{0,4},{2,4},{2,2},{1,2},{2,2},{2,0},{0,0},{1,0},{1,4}},\nC = {{2,0},{0,0},{0,4},{2,4}},\nD = {{0,4},{2,4},{2,0},{0,0},{1,0},{1,4}},\nE = {{2,0},{0,0},{0,2},{1,2},{0,2},{0,4},{2,4}},\nF = {{2,0},{0,0},{0,2},{1,2},{0,2},{0,4}},\nG = {{2,0},{0,0},{0,4},{2,4},{2,2},{1,2}},    \nH = {{0,0},{0,4},{0,2},{2,2},{2,4},{2,0}},\nI = {{0,0},{2,0},{1,0},{1,4},{0,4},{2,4}},\nJ = {{0,2},{0,4},{2,4},{2,0}},\nK = {{0,0},{0,4},{0,2},{1,2},{2,0},{1,2},{2,4}},\nL = {{0,0},{0,4},{2,4}},\nM = {{0,4},{0,0},{1,2},{2,0},{2,4}},\nN = {{0,4},{0,0},{2,4},{2,0}},\nO = {{0,0},{0,4},{2,4},{2,0},{0,0}},\nP = {{0,4},{0,0},{2,0},{2,2},{0,2}},\nQ = {{2,4},{0,4},{0,0},{2,0},{2,4},{1,2}},\nR = {{0,4},{0,0},{2,0},{2,2},{0,2},{1,2},{2,4}},\nS = {{2,0},{0,0},{0,2},{2,2},{2,4},{0,4}},\nT = {{0,0},{2,0},{1,0},{1,4}},\nU = {{0,0},{0,4},{2,4},{2,0}},\nV = {{0,0},{0,4},{2,0}},\nW = {{0,0},{0,4},{1,2},{2,4},{2,0}},\nX = {{0,0},{2,4},{1,2},{2,0},{0,4}},\nY = {{0,0},{0,2},{2,2},{2,0},{2,2},{1,2},{1,4}},\nZ = {{0,0},{2,0},{0,4},{2,4}},\nn0 = {{0,0},{0,4},{2,4},{2,0},{0,0},{2,4}},\nn1 = {{1,2},{2,0},{2,4}},\nn2 = {{0,0},{2,0},{2,2},{0,2},{0,4},{2,4}},\nn3 = {{0,0},{2,0},{2,2},{1,2},{2,2},{2,4},{0,4}},\nn4 = {{0,0},{0,2},{2,2},{2,0},{2,4}},\nn5 = {{2,0},{0,0},{0,2},{2,2},{2,4},{0,4}},\nn6 = {{0,0},{0,4},{2,4},{2,2},{0,2}},\nn7 = {{0,0},{2,0},{0,4}},\nn8 = {{0,2},{0,0},{2,0},{2,2},{0,2},{0,4},{2,4},{2,2}},\nn9 = {{2,2},{0,2},{0,0},{2,0},{2,4}}, \n}\n\nlocal find, sub, gsub = string.find, string.sub, string.gsub\nlocal text2table = {}\nlocal nLines = select(2, gsub(textInput.text, \"|\", \"\"))\nlocal n = 1\nlocal l = 0\ntext2table[n] = {}\nwhile n <= nLines do\n    for i=1, #textInput.text do\n        local str = sub(textInput.text,i,i)\n        if tonumber(str) == nil then\n            if find(\"|\",str) then\n                n = n + 1\n                text2table[n] = {}\n            elseif select(2, gsub(\" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\", str, \"\")) > 0 then\n                text2table[n][#text2table[n]+1] = str:upper()\n            else\n                system.print(\"error\")\n                text2table = {{\"O\",\"N\",\"L\",\"Y\",\" \",\"A\",\"L\",\"P\",\"H\",\"A\",\" \",\"N\",\"U\",\"M\",\"E\",\"R\",\"I\",\"C\",\" \",\"C\",\"H\",\"A\",\"R\",\"A\",\"C\",\"T\",\"E\",\"R\",\"S\",\" \",\"A\",\"C\",\"C\",\"E\",\"P\",\"T\",\"E\",\"D\"}}\n                break\n            end\n        else\n            text2table[n][#text2table[n]+1] = \"n\"..str\n        end\n    end\n    n = n + 1\nend\n\ntext3D = {}\ntext3DWorldPos = {}\nlocal textOffsetX = 0\nfor i, v in ipairs(text2table) do\n    if textInput.alignment == \"middle\" then\n        textOffsetX = -1 * (#text2table[i]*2*textInput.height/4+textInput.spacing.x*(#text2table[i]-1)) / 2\n    elseif textInput.alignment == \"left\" then\n        textOffsetX = 0\n    elseif textInput.alignment == \"right\" then\n        textOffsetX = -1 *(#text2table[i]*2*textInput.height/4+textInput.spacing.x*(#text2table[i]-1))\n    end \n    local textOffsetY = 0\n    if textInput.baseline == \"middle\" then\n        textOffsetY = (-2*textInput.height/4) + (textInput.height + textInput.spacing.y)*(i-1)\n    elseif textInput.baseline == \"top\" then\n        textOffsetY = (textInput.height + textInput.spacing.y)*(i-1)\n    elseif textInput.baseline == \"bottom\" then\n        textOffsetY = (-4*textInput.height/4) + (textInput.height + textInput.spacing.y)*(i-1)\n    end \n    for i2, v2 in ipairs(text2table[i]) do\n        if v2 ~= \" \" then\n            local an = alphaNum[v2]\n            local offsetShape = {}\n            for i3, v3 in ipairs(an) do\n                offsetShape[#offsetShape+1] = {\n                (v3[1])* textInput.height / 4 \n                        + textOffsetX \n                        + textInput.offset.x\n                        + (textInput.spacing.x + textInput.height / 2)*(i2-1), \n                (v3[2])* textInput.height / 4 \n                        + textOffsetY\n                        - textInput.offset.y \n                }\n            end\n            text3D[#text3D+1] = offsetShape\n        end\n    end\nend \n\n--                ((v3[1])* textInput.scale.x \n--                        + textInput.spacing.x*(i2-1) \n --                       + 2*(i2-1) \n --                       + textOffsetX)*textInput.height / 4 \n --                       + textInput.offset.x, \n\ntextRot = 0\n\n--unit.hide()\nsystem.showScreen(1)\n--system.print(\"script started!\")\n\nfps = 0\nuCount = 0\nunit.setTimer(\"fps\",1)","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"fps = uCount\nuCount = 0","filter":{"args":[{"value":"fps"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"1"},{"code":"local sgt = system.getArkTime()\n\nlocal sqrt, tan, rad = math.sqrt, math.tan, math.rad\nlocal sw = system.getScreenWidth()\nlocal sh = system.getScreenHeight()\nlocal vFov = system.getCameraVerticalFov()\nlocal near = 0.1\nlocal far = 100000000.0\nlocal aspectRatio = sh/sw\nlocal tanFov = 1.0/tan(rad(vFov)*0.5)\nlocal field = -far/(far-near)\nlocal af = aspectRatio*tanFov\nlocal nq = near*field\nlocal camPv3 = vec3(system.getCameraPos())\nlocal camWP = system.getCameraWorldPos()\nlocal camWPv3 = vec3(camWP)\nlocal camWPx, camWPy, camWPz = camWP[1], camWP[2], camWP[3]\nlocal camWF = system.getCameraWorldForward()\nlocal camWFv3 = vec3(camWF)\nlocal camWFx, camWFy, camWFz = camWF[1], camWF[2], camWF[3]\nlocal camWR = system.getCameraWorldRight()\nlocal camWRx, camWRy, camWRz = camWR[1], camWR[2], camWR[3]\nlocal camWU = system.getCameraWorldUp()\nlocal camWUx, camWUy, camWUz = camWU[1], camWU[2], camWU[3]\n\nlocal cWP = construct.getWorldPosition()\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\nlocal mPP = player.getPosition()\nlocal mPPx, mPPy = mPP[1], mPP[2]\n\nlocal posX, posY, posZ = 0, 0, 0\nlocal vx, vy, vz = 0, 0, 0\nlocal sx, sy, sz = 0, 0, 0\nlocal sPX, sPY = 0\nlocal dist = 0\n\nlocal function projection2D()\n    -- matrix resolution\n    vx = posX * camWRx + posY * camWRy + posZ * camWRz\n    vy = posX * camWFx + posY * camWFy + posZ * camWFz\n    vz = posX * camWUx + posY * camWUy + posZ * camWUz\n    -- 2D projection\n    sx = (af * vx)/vy\n    sy = ( -tanFov * vz)/vy\n    sz = ( -field * vy + nq)/vy\n    sPX, sPY = (sx+1)*sw*0.5, (sy+1)*sh*0.5 -- screen pos X Y\n    dist = sqrt(posX*posX + posY*posY + posZ*posZ) -- distance from camera to pos\nend\n\nlocal SVG = [[\n<style>\n    .labelWhite {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: white;}\n    .labelYellow {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: gold;}\n    .labelRed {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: red;}  \n    .label {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: white;} \n    .hud {text-anchor: start; font-family: Play; alignment-baseline: middle; stroke-width: 2; fill: red;}\n    .text {stroke-width:10; stroke:red; fill:none; stroke-linecap:round; stroke-linejoin:round}\n    .middle {stroke-width:5; stroke:red; fill:none; stroke-linecap:round; stroke-linejoin:round}\n</style>]]\n\n\n--Markers\n----------\nlocal t = \"\"\nlocal style = \"labelWhite\"\nlocal ind = 0\nlocal n1, n2, n3 = 0, 0, 0\nlocal tempSVG = \"\"\nlocal svgOut = false\n\nfor i, v in ipairs(text3DWorldPos) do\n    svgOut = false\n    tempSVG = [[<polyline class=\"text]]..i..[[\" points=\"]]\n    for i2, v2 in ipairs(v) do\n        posX = v2.x - camWPx\n        posY = v2.y - camWPy\n        posZ = v2.z - camWPz\n        projection2D()\n        tempSVG = tempSVG .. sPX .. \",\" .. sPY .. \" \" \n        if sz > 1 or sPX < 0 or sPX > sw or sPY < 0 or sPY > sh then svgOut = true end\n    end\n    tempSVG = tempSVG .. [[\"/>]]\n    if svgOut == false then\n        ind = ind+1\n        SVG = SVG..[[\n        <style>\n        .text]]..i..[[ {stroke-width:]].. 1 / dist * textInput.stroke ..[[; stroke: ]].. textInput.color ..[[; fill: none; stroke-linecap:round; stroke-linejoin:round}\n        </style>]]\n        SVG = SVG .. tempSVG\n    end\nend\n\n\nhtml = [[\n<style>\nsvg {\nposition:absolute;\ntop:0px;\nleft:0px\n}\n</style>\n\n<div>\n<svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\">\n]].. SVG ..[[\n</svg>\n</div>\n]]\n\nsystem.setScreen(html)\n-- ▲☺☻♥♦♣♠•◘◙♂♀♪♫☼►↑☠\nuCount = uCount + 1","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"2"},{"code":"local sqrt, rad, random, cos, sin = math.sqrt, math.rad, math.random, math.cos, math.sin\n\nlocal cWP = construct.getWorldPosition()\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n\nlocal x = 0\nlocal y = 0\nlocal z = 0\nlocal vxyz = {}\nlocal vx = 0\nlocal vy = 0\nlocal vz = 0\nlocal p = {}\nlocal t = {}\nadjustorPos = core.getElementPositionById(adjustorID)\n\nfor i, v in ipairs(text3D) do\n    p = {}\n    t = v\n    for i2, v2 in ipairs(t) do\n        vx,vy,vz = v2[1] + adjustorPos[1], 0 + adjustorPos[2], -v2[2] + adjustorPos[3]\n        x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n        y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n        z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n        p[#p+1] = {x=x,y=y,z=z}\n    end\n    text3DWorldPos[i] = p\nend\n\nvx,vy,vz = adjustorPos[1], adjustorPos[2], adjustorPos[3]\nx = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\ny = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\nz = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\nadjustorPos = {x=x,y=y,z=z}\n\nlocal function normalizeVec(x,y,z) -- normalize unpacked vector\n    local l = sqrt(x*x + y*y + z*z)\n    return x/l, y/l, z/l\nend\n\nlocal function dotVec(x1,y1,z1,x2,y2,z2) -- dot product of unpacked vectors\n    return x1*x2 + y1*y2 + z1*z2\nend\n\nlocal function rotateVec(vx, vy, vz, phi, ax, ay, az) --rotation of unpacked vec : vector to rotate / rotation angle in rad / axis vector\n    local l = sqrt(ax*ax + ay*ay + az*az)\n    local ux, uy, uz = ax/l, ay/l, az/l\n    local c, s = cos(phi), sin(phi)\n    local m1x, m1y, m1z = (c + ux * ux * (1-c)), (ux * uy * (1-c) - uz * s), (ux * uz * (1-c) + uy * s)\n    local m2x, m2y, m2z = (uy * ux * (1-c) + uz * s), (c + uy * uy * (1-c)), (uy * uz * (1-c) - ux * s)\n    local m3x, m3y, m3z = (uz * ux * (1-c) - uy * s), (uz * uy * (1-c) + ux * s), (c + uz * uz * (1-c))\n    return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz\nend\n\nlocal adjUp = core.getElementUpById(adjustorID) -- translation of adjustor local coords in world coords\nlocal adjX, adjY, adjZ = 0, 0, 0\nvx,vy,vz = adjUp[1], adjUp[2], adjUp[3]\nx = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\ny = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\nz = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\nadjX, adjY, adjZ = x, y, z\n\ntextRot = textRot < 360 and textRot + 0.5 or 0 -- rotation animation\n\nlocal rx, ry, rz = 0, 0, 0\nfor i, v in ipairs(text3DWorldPos) do -- loop through inputText to adjust each letter rotation\n    for i2, v2 in ipairs(v) do\n        rx, ry, rz = rotateVec(v2.x-adjustorPos.x, v2.y-adjustorPos.y, v2.z-adjustorPos.z, \n                                rad(textRot), \n                                cWOUx, cWOUy, cWOUz)\n        text3DWorldPos[i][i2] = {x=rx+adjustorPos.x, y=ry+adjustorPos.y, z=rz+adjustorPos.z}\n    end\nend\n\nlocal mWPP = player.getWorldPosition()\nlocal mWPPx, mWPPy, mWPPz = mWPP[1], mWPP[2], mWPP[3]\nlocal function vectorLen(x,y,z)\n    return sqrt(x * x + y * y + z * z)\nend\nif vectorLen(adjustorPos.x-mWPPx,adjustorPos.y-mWPPy,adjustorPos.z-mWPPz)>8 then unit.exit()end","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"3"},{"code":"text3D = {}\ntext3DWorldPos = {}\n\nlocal text2table = {}\n\nfor i=1, #text do\n    local str = string.sub(text,i,i)\n    if tonumber(str) == nil then\n        text2table[i] = str:upper()\n    else\n        text2table[i] = \"n\"..str\n    end\nend\n    \nfor i, v in ipairs(text2table) do\n    if v ~= \" \" then\n        local an = alphaNum[v]\n        local offsetShape = {}\n        for i2, v2 in ipairs(an) do\n            offsetShape[#offsetShape+1] = {(v2[1] + textInput.spacing*(i-1) + 2*(i-1) + textOffsetX + textInput.offsetX)*textInput.height/4, (v2[2] + textOffsetY - textInput.offsetY)*textInput.height/4}\n        end\n        text3D[#text3D+1] = offsetShape\n    end\nend ","filter":{"args":[{"variable":"*"}],"signature":"onInputText(text)","slotKey":"-4"},"key":"4"}],"methods":[],"events":[]}