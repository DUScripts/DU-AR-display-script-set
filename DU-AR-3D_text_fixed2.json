{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"--textInput = {text = \"JSE PLUS PLUS|Space Elevator Tech|since 2019|||*space station*|*floor 6*|*floor 5*|*floor 4*|*floor 3*|*floor 2*|*ground floor*\", \ntextInput = {text = \"PENROSE ORGANISATION||A recruiting FRENCH PVE PVP ORG|offering a large variety of services||*trade*|*builds*|*scripts*||feel free jump in the PENROSE CITADELLE VR\", \n    alignment = \"middle\", --left / middle / right\n    baseline = \"top\", --top / middle / bottom\n    height = 0.1, --height in meter\n    color = \"orange\", --color in named webcolor\n    stroke = 8, --stroke width\n    spacing = {x = 0.02, y = 0.08}, --spacing between letters and lines\n    offset = {x = -0, y = 0.2}, --additionnal offset from origine point in meters\n    rotation = {x = 0, y = 0, z = 0} --wip\n}\n\ncurrentPolygon = 0\ntextInputFunctions = {}\ntextInputFunctions = {nil,nil,nil,nil,nil,\n                    function() system.print(\"TRADE\") end,\n                    function() system.print(\"BUILDS\") end,\n                    function() system.print(\"SCRIPTS\") end,\n                    function() system.print(\"FLOOR 4\") end,\n                    function() system.print(\"FLOOR 3\") end, \n                    function() system.print(\"FLOOR 2\") end, \n                    function() system.print(\"GROUND FLOOR\") end,}\n\ncore = {}\nadjustor = {}\nadjustor1ID = 0\nadjustor2ID = 0\nadjustor3ID = 0\nadjustor4ID = 0\nadjustor5ID = 0\n\nadjustorTag = {}\n\nlocal function findConnectedSlots()\n    local slot = {}\n    for slotName in pairs(unit) do\n        slot = unit[slotName]\n        if type(slot)=='table' and unit[slotName].getClass ~= nil and slotName~='system' and slotName~='library' and slotName~='unit' and slotName~='export' then\n            --system.print(slot.getClass())\n            if string.sub(slot.getClass(),1,8) == \"CoreUnit\" then\n                core = slot\n                --system.print(\"Core found\")\n            end\n            if string.sub(slot.getClass(),1,8) == \"Adjustor\"then\n                adjustor = slot\n                adjustor1ID = adjustor.getLocalId()\n                --system.print(\"Adjustor 1 found\")\n            end\n            if string.sub(slot.getClass(),1,8) == \"Adjustor\" and slot.getTags() == \"2\" then\n                adjustor = slot\n                adjustor2ID = adjustor.getLocalId()\n                --system.print(\"Adjustor 2 found\")\n            end\n            if string.sub(slot.getClass(),1,8) == \"Adjustor\" and slot.getTags() == \"3\" then\n                adjustor = slot\n                adjustor3ID = adjustor.getLocalId()\n                --system.print(\"Adjustor 3 found\")\n            end\n            if string.sub(slot.getClass(),1,8) == \"Adjustor\" and slot.getTags() == \"4\" then\n                adjustor = slot\n                adjustor4ID = adjustor.getLocalId()\n                --system.print(\"Adjustor 4 found\")\n            end\n            if string.sub(slot.getClass(),1,8) == \"Adjustor\" and slot.getTags() == \"5\" then\n                adjustor = slot\n                adjustor5ID = adjustor.getLocalId()\n                --system.print(\"Adjustor 5 found\")\n            end\n        end\n    end\nend\nfindConnectedSlots()\n\nlocal adjPos = core.getElementPositionById(adjustor1ID)\nadjustorPos = {x=adjPos[1] ,y=adjPos[2] ,z=adjPos[3] }\n\nalphaNum = {\nA = {{0,4},{0,0},{2,0},{2,4},{2,2},{0,2}},\nB = {{0,4},{2,4},{2,2},{1,2},{2,2},{2,0},{0,0},{1,0},{1,4}},\nC = {{2,0},{0,0},{0,4},{2,4}},\nD = {{0,4},{2,4},{2,0},{0,0},{1,0},{1,4}},\nE = {{2,0},{0,0},{0,2},{1,2},{0,2},{0,4},{2,4}},\nF = {{2,0},{0,0},{0,2},{1,2},{0,2},{0,4}},\nG = {{2,0},{0,0},{0,4},{2,4},{2,2},{1,2}},    \nH = {{0,0},{0,4},{0,2},{2,2},{2,4},{2,0}},\nI = {{0,0},{2,0},{1,0},{1,4},{0,4},{2,4}},\nJ = {{0,2},{0,4},{2,4},{2,0}},\nK = {{0,0},{0,4},{0,2},{1,2},{2,0},{1,2},{2,4}},\nL = {{0,0},{0,4},{2,4}},\nM = {{0,4},{0,0},{1,2},{2,0},{2,4}},\nN = {{0,4},{0,0},{2,4},{2,0}},\nO = {{0,0},{0,4},{2,4},{2,0},{0,0}},\nP = {{0,4},{0,0},{2,0},{2,2},{0,2}},\nQ = {{2,4},{0,4},{0,0},{2,0},{2,4},{1,2}},\nR = {{0,4},{0,0},{2,0},{2,2},{0,2},{1,2},{2,4}},\nS = {{2,0},{0,0},{0,2},{2,2},{2,4},{0,4}},\nT = {{0,0},{2,0},{1,0},{1,4}},\nU = {{0,0},{0,4},{2,4},{2,0}},\nV = {{0,0},{0,4},{2,0}},\nW = {{0,0},{0,4},{1,2},{2,4},{2,0}},\nX = {{0,0},{2,4},{1,2},{2,0},{0,4}},\nY = {{0,0},{0,2},{2,2},{2,0},{2,2},{1,2},{1,4}},\nZ = {{0,0},{2,0},{0,4},{2,4}},\nn0 = {{0,0},{0,4},{2,4},{2,0},{0,0},{2,4}},\nn1 = {{1,2},{2,0},{2,4}},\nn2 = {{0,0},{2,0},{2,2},{0,2},{0,4},{2,4}},\nn3 = {{0,0},{2,0},{2,2},{1,2},{2,2},{2,4},{0,4}},\nn4 = {{0,0},{0,2},{2,2},{2,0},{2,4}},\nn5 = {{2,0},{0,0},{0,2},{2,2},{2,4},{0,4}},\nn6 = {{0,0},{0,4},{2,4},{2,2},{0,2}},\nn7 = {{0,0},{2,0},{0,4}},\nn8 = {{0,2},{0,0},{2,0},{2,2},{0,2},{0,4},{2,4},{2,2}},\nn9 = {{2,2},{0,2},{0,0},{2,0},{2,4}}, \n}\n\nlocal find, sub, gsub = string.find, string.sub, string.gsub\nlocal text2table = {}\nlocal nLines = select(2, gsub(textInput.text, \"|\", \"\"))\nlocal n = 1\nlocal l = 0\ntext2table[n] = {}\n\nwhile n <= nLines do\n    for i=1, #textInput.text do\n        local str = sub(textInput.text,i,i)\n        if tonumber(str) == nil then\n            if str == \"|\" then\n                n = n + 1\n                text2table[n] = {}\n            elseif select(2, gsub(\" abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ*\", str, \"\")) > 0 then\n                if str == \"*\" then \n                    text2table[n][#text2table[n]+1] = \"*\"\n                else\n                    text2table[n][#text2table[n]+1] = str:upper()\n                end\n            else\n                system.print(\"error\")\n                text2table = {{\"O\",\"N\",\"L\",\"Y\",\" \",\"A\",\"L\",\"P\",\"H\",\"A\",\" \",\"N\",\"U\",\"M\",\"E\",\"R\",\"I\",\"C\",\" \",\"C\",\"H\",\"A\",\"R\",\"A\",\"C\",\"T\",\"E\",\"R\",\"S\",\" \",\"A\",\"C\",\"C\",\"E\",\"P\",\"T\",\"E\",\"D\"}}\n                break\n            end\n        else\n            text2table[n][#text2table[n]+1] = \"n\"..str\n        end\n    end\n    n = n + 1\nend\n\ntext3D = {}\ntext3DWorldPos = {}\ntextFraming = {}\nframe3DWorldPos = {}\nlocal textOffsetX = 0\nlocal textOffsetY = 0\nlocal addOffsetY = 0\nfor i, v in ipairs(text2table) do\n    if textInput.alignment == \"middle\" then\n        textOffsetX = -1 * (#text2table[i]*2*textInput.height/4+textInput.spacing.x*(#text2table[i]-1)) / 2\n    elseif textInput.alignment == \"left\" then\n        textOffsetX = 0\n    elseif textInput.alignment == \"right\" then\n        textOffsetX = -1 *(#text2table[i]*2*textInput.height/4+textInput.spacing.x*(#text2table[i]-1))\n    end \n    local textOffsetY = 0\n    if textInput.baseline == \"middle\" then\n        textOffsetY = (-2*textInput.height/4) + (textInput.height + textInput.spacing.y)*(i-1)\n    elseif textInput.baseline == \"top\" then\n        textOffsetY = (textInput.height + textInput.spacing.y)*(i-1)\n    elseif textInput.baseline == \"bottom\" then\n        textOffsetY = (-4*textInput.height/4) + (textInput.height + textInput.spacing.y)*(i-1)\n    end \n    addOffsetY = #text2table*(textInput.height + textInput.spacing.y)\n\n    for i2, v2 in ipairs(text2table[i]) do\n        if v2 ~= \" \" then\n            if v2 ~= \"*\" then\n                local an = alphaNum[v2]\n                local offsetShape = {}\n                for i3, v3 in ipairs(an) do\n                    offsetShape[#offsetShape+1] = {\n                    (v3[1])* textInput.height / 4 \n                        + textOffsetX \n                        + textInput.offset.x\n                        + (textInput.spacing.x + textInput.height / 2)*(i2-1), \n                    (v3[2])* textInput.height / 4 \n                        + textOffsetY\n                        - textInput.offset.y\n                        - addOffsetY\n                    }\n                end\n                text3D[#text3D+1] = offsetShape\n            elseif v2 == \"*\" then\n                if textFraming[i] == nil then\n                    local an = {{0,-1},{0,5}}\n                    local offsetShape = {}\n                    for i3, v3 in ipairs(an) do\n                        offsetShape[#offsetShape+1] = {\n                        (v3[1])* textInput.height / 4 \n                            + textOffsetX \n                            + textInput.offset.x\n                            + (textInput.spacing.x + textInput.height / 2)*(i2-1), \n                        (v3[2])* textInput.height / 4 \n                            + textOffsetY\n                            - textInput.offset.y\n                            - addOffsetY\n                        }\n                    end\n                    textFraming[i] = offsetShape\n                elseif textFraming[i] ~= nil then\n                    local an = {{2,5},{2,-1}}\n                    local offsetShape = {}\n                    for i3, v3 in ipairs(an) do\n                        offsetShape[#offsetShape+1] = {\n                        (v3[1])* textInput.height / 4 \n                            + textOffsetX \n                            + textInput.offset.x\n                            + (textInput.spacing.x + textInput.height / 2)*(i2-1), \n                        (v3[2])* textInput.height / 4 \n                            + textOffsetY\n                            - textInput.offset.y \n                            - addOffsetY\n                        }\n                    end\n                    local t = textFraming[i]\n                    for i4, v4 in ipairs(offsetShape) do\n                        t[#t+1] = v4\n                        if i4 == #offsetShape then t[#t+1] = t[1] end\n                    end\n                    textFraming[i] = t\n                end\n            end\n        end\n    end\nend \n\naxis3DWorldPos = {}\n\ntextRot = 0\n\n--unit.hide()\nsystem.showScreen(1)\n--system.print(\"script started!\")\n\nfps = 0\nuCount = 0\nunit.setTimer(\"fps\",1)\n\npDampOffset = {0,0}\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"fps = uCount\nuCount = 0","filter":{"args":[{"value":"fps"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"1"},{"code":"local sgt = system.getArkTime()\n\nlocal sqrt, tan, rad = math.sqrt, math.tan, math.rad\nlocal sw = system.getScreenWidth()\nlocal sh = system.getScreenHeight()\nlocal vFov = system.getCameraVerticalFov()\nlocal near = 0.1\nlocal far = 100000000.0\nlocal aspectRatio = sh/sw\nlocal tanFov = 1.0/tan(rad(vFov)*0.5)\nlocal field = -far/(far-near)\nlocal af = aspectRatio*tanFov\nlocal nq = near*field\nlocal camPv3 = vec3(system.getCameraPos())\nlocal camWP = system.getCameraWorldPos()\nlocal camWPv3 = vec3(camWP)\nlocal camWPx, camWPy, camWPz = camWP[1], camWP[2], camWP[3]\nlocal camWF = system.getCameraWorldForward()\nlocal camWFv3 = vec3(camWF)\nlocal camWFx, camWFy, camWFz = camWF[1], camWF[2], camWF[3]\nlocal camWR = system.getCameraWorldRight()\nlocal camWRx, camWRy, camWRz = camWR[1], camWR[2], camWR[3]\nlocal camWU = system.getCameraWorldUp()\nlocal camWUx, camWUy, camWUz = camWU[1], camWU[2], camWU[3]\n\nlocal cWP = construct.getWorldPosition()\n--local cWPv3 = vec3(core.getConstructWorldPos())\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\nlocal mPP = player.getPosition()\nlocal mPPx, mPPy = mPP[1], mPP[2]\n\nlocal posX, posY, posZ = 0, 0, 0\nlocal vx, vy, vz = 0, 0, 0\nlocal sx, sy, sz = 0, 0, 0\nlocal sPX, sPY = 0\nlocal dist = 0\n\nlocal function projection2D()\n    -- matrix resolution\n    vx = posX * camWRx + posY * camWRy + posZ * camWRz\n    vy = posX * camWFx + posY * camWFy + posZ * camWFz\n    vz = posX * camWUx + posY * camWUy + posZ * camWUz\n    -- 2D projection\n    sx = (af * vx)/vy\n    sy = ( -tanFov * vz)/vy\n    sz = ( -field * vy + nq)/vy\n    sPX, sPY = (sx+1)*sw*0.5, (sy+1)*sh*0.5 -- screen pos X Y\n    dist = sqrt(posX*posX + posY*posY + posZ*posZ) -- distance from camera to pos\nend\n\nlocal function pointInPolygon( x, y, polygon)\n  local points= polygon\n\t\n  local i, j = #points, #points\n  local inside = false\n\n  for i=1, #points do\n    if ((points[i].y < y and points[j].y>=y or points[j].y< y and points[i].y>=y) and (points[i].x<=x or points[j].x<=x)) then\n      if (points[i].x+(y-points[i].y)/(points[j].y-points[i].y)*(points[j].x-points[i].x)<x) then\n        inside = not inside\n      end\n    end\n    j = i\n  end\n\n  return inside\nend\n\nlocal SVG = [[\n<style>\n    .labelWhite {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: white;}\n    .labelYellow {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: gold;}\n    .labelRed {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: red;}  \n    .label {text-anchor: middle; font-family: Play; alignment-baseline: middle; stroke-width: 0; fill: white;} \n    .hud {text-anchor: start; font-family: Play; alignment-baseline: middle; stroke-width: 2; fill: red;}\n    .text {stroke-width:10; stroke:red; fill:none; stroke-linecap:round; stroke-linejoin:round}\n    .middle {stroke-width:5; stroke:red; fill:none; stroke-linecap:round; stroke-linejoin:round}\n</style>]]\n\n\n--Markers\n----------\nlocal t = \"\"\nlocal style = \"labelWhite\"\nlocal ind = 0\nlocal n1, n2, n3 = 0, 0, 0\nlocal tempSVG = \"\"\nlocal svgOut = false\nlocal polygon = {}\n\nlocal MDX = system.getMouseDeltaX()*0\nlocal MDY = system.getMouseDeltaY()*0\n\nposX = adjustorPos.x - camWPx\nposY = adjustorPos.y - camWPy\nposZ = adjustorPos.z - camWPz\nprojection2D()\n\n\ncurrentPolygon = 0\nfor i, v in pairs(frame3DWorldPos) do\n    polygon = {}\n    svgOut = false\n    tempSVG = [[<polyline class=\"frame]]..i..[[\" points=\"]]\n    for i2, v2 in ipairs(v) do\n        posX = v2.x - camWPx\n        posY = v2.y - camWPy\n        posZ = v2.z - camWPz\n        projection2D()\n        polygon[#polygon+1] = {x=sPX,y=sPY}\n        tempSVG = tempSVG .. sPX - MDX .. \",\" .. sPY - MDY .. \" \"\n        if sz > 1 or sPX < 0 or sPX > sw or sPY < 0 or sPY > sh then svgOut = true end\n    end\n    tempSVG = tempSVG .. [[\"/>]]\n    \n    if svgOut == false then\n        local fill = \"white\"\n        if pointInPolygon( sw/2, sh/2, polygon) == true then fill = \"red\" currentPolygon = i end\n        ind = ind+1\n        SVG = SVG..[[\n        <style>\n        .frame]]..i..[[ {stroke-width:]].. 1 / dist * textInput.stroke ..[[; stroke: ]].. textInput.color ..[[; fill: ]]..fill..[[; fill-opacity: 0.3; stroke-linecap:round; stroke-linejoin:round}\n        </style>]]\n        SVG = SVG .. tempSVG\n    end\nend\n\nfor i, v in ipairs(text3DWorldPos) do\n    svgOut = false\n    tempSVG = [[<polyline class=\"text]]..i..[[\" points=\"]]\n    for i2, v2 in ipairs(v) do\n        posX = v2.x - camWPx\n        posY = v2.y - camWPy\n        posZ = v2.z - camWPz\n        projection2D()\n        tempSVG = tempSVG .. sPX - MDX .. \",\" .. sPY - MDY .. \" \"\n        if sz > 1 or sPX < 0 or sPX > sw or sPY < 0 or sPY > sh then svgOut = true end\n    end\n    tempSVG = tempSVG .. [[\"/>]]\n    if svgOut == false then\n        ind = ind+1\n        SVG = SVG..[[\n        <style>\n        .text]]..i..[[ {stroke-width:]].. 1 / dist * textInput.stroke ..[[; stroke: ]].. textInput.color ..[[; fill: none; stroke-linecap:round; stroke-linejoin:round}\n        </style>]]\n        SVG = SVG .. tempSVG\n    end\nend\n\n\n\nSVG = SVG .. [[<text x=\"20\" y=\"20\" class=\"hud\" font-size=\"20\" >AR Ship Info - by Jeronimo 2022</text> \n            <text x=\"20\" y=\"40\" class=\"hud\" font-size=\"20\" >FPS: ]].. fps ..[[</text>\n            <text x=\"20\" y=\"60\" class=\"hud\" font-size=\"20\" >AR points displayed: ]].. ind ..[[</text>]]\n            .. string.format([[<text x=\"20\" y=\"80\" class=\"hud\" font-size=\"20\" >Update execution speed: %.3fms</text>]], (system.getArkTime() - sgt)*1000 )\n\nhtml = [[\n<style>\nsvg {\nposition:absolute;\ntop:0px;\nleft:0px\n}\n</style>\n\n<div>\n<svg viewBox=\"0 0 ]].. sw ..[[ ]].. sh ..[[\">\n]].. SVG ..[[\n</svg>\n</div>\n]]\n\nsystem.setScreen(html)\n-- ▲☺☻♥♦♣♠•◘◙♂♀♪♫☼►↑☠\nuCount = uCount + 1","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"2"},{"code":"local sqrt, rad, random, cos, sin, acos, clamp = math.sqrt, math.rad, math.random, math.cos, math.sin, math.acos, utils.clamp\n\nlocal function dotVec(x1,y1,z1,x2,y2,z2)\n    return x1*x2 + y1*y2 + z1*z2\nend\n\nlocal function vectorLen(x,y,z)\n    return sqrt(x * x + y * y + z * z)\nend\n\nlocal function normalizeVec(x,y,z) -- normalize unpacked vector\n    local l = sqrt(x*x + y*y + z*z)\n    return x/l, y/l, z/l\nend\n\nlocal function cross(x, y, z, vx, vy, vz)\n    return y*vz - z*vy, z*vx - x*vz, x*vy - y*vx\nend\n\nlocal function getConstructRot(x, y, z) --UPDATED\n    if x == nil then x, y, z = -1,0,0 end\n    x, y, z = normalizeVec(x,y,z)\n    local CRx, CRy, CRz = 1, 0, 0\n    local CUx, CUy, CUz = 0, 0, 1\n    local cx, cy, cz = cross(x, y, z, CUx, CUy, CUz)\n    local rAx, rAy, rAz =  normalizeVec(cx, cy, cz) -- rot axis\n    local ConstructRot = acos(clamp(dotVec(rAx, rAy, rAz,CRx, CRy, CRz), -1, 1))\n    cx, cy, cz = cross(rAx, rAy, rAz, CRx, CRy, CRz)\n    if dotVec(cx, cy, cz, CUx, CUy, CUz) > 0 then ConstructRot = -ConstructRot end --system.print(\"rot: \"..ConstructRot)\n    return ConstructRot\nend\n\nlocal function rotateVec(vx, vy, vz, phi, ax, ay, az) --rotation of unpacked vec : vector to rotate / rotation angle in rad / axis vector\n    local l = sqrt(ax*ax + ay*ay + az*az)\n    local ux, uy, uz = ax/l, ay/l, az/l\n    local c, s = cos(phi), sin(phi)\n    local m1x, m1y, m1z = (c + ux * ux * (1-c)), (ux * uy * (1-c) - uz * s), (ux * uz * (1-c) + uy * s)\n    local m2x, m2y, m2z = (uy * ux * (1-c) + uz * s), (c + uy * uy * (1-c)), (uy * uz * (1-c) - ux * s)\n    local m3x, m3y, m3z = (uz * ux * (1-c) - uy * s), (uz * uy * (1-c) + ux * s), (c + uz * uz * (1-c))\n    return m1x*vx+m1y*vy+m1z*vz, m2x*vx+m2y*vy+m2z*vz, m3x*vx+m3y*vy+m3z*vz\nend\n\nlocal cWP = construct.getWorldPosition()\nlocal cWPx, cWPy, cWPz = cWP[1], cWP[2], cWP[3]\nlocal cWOU = construct.getWorldOrientationUp()\nlocal cWOUx, cWOUy, cWOUz = cWOU[1], cWOU[2], cWOU[3]\nlocal cWOF = construct.getWorldOrientationForward()\nlocal cWOFx, cWOFy, cWOFz = cWOF[1], cWOF[2], cWOF[3]\nlocal cWOR = construct.getWorldOrientationRight()\nlocal cWORx, cWORy, cWORz = cWOR[1], cWOR[2], cWOR[3]\n\nlocal x = 0\nlocal y = 0\nlocal z = 0\nlocal vxyz = {}\nlocal vx = 0\nlocal vy = 0\nlocal vz = 0\nlocal p = {}\nlocal t = {}\n--\nadjustorPos = core.getElementPositionById(adjustor1ID)\nlocal adjPx, adjPy, adjPz = adjustorPos[1], adjustorPos[2], adjustorPos[3]\nlocal adjFor = core.getElementForwardById(adjustor1ID)\nlocal adjustorForx, adjustorFory, adjustorForz = adjFor[1], adjFor[2], adjFor[3]\nlocal adjRig = core.getElementRightById(adjustor1ID)\nlocal adjustorRigx, adjustorRigy, adjustorRigz = adjRig[1], adjRig[2], adjRig[3]\nlocal adjUp = core.getElementUpById(adjustor1ID)\nlocal adjustorUpx, adjustorUpy, adjustorUpz = adjUp[1], adjUp[2], adjUp[3]\n\nlocal adjRot = getConstructRot(adjustorRigx, adjustorRigy, adjustorRigz)\n--system.print(math.deg(adjRot))\n\nlocal adjAxis3d = {{{adjPx, adjPy, adjPz},{adjPx+adjustorForx, adjPy+adjustorFory, adjPz+adjustorForz}},\n                   {{adjPx, adjPy, adjPz},{adjPx+adjustorRigx, adjPy+adjustorRigy, adjPz+adjustorRigz}},\n                    {{adjPx, adjPy, adjPz},{adjPx+adjustorUpx, adjPy+adjustorUpy, adjPz+adjustorUpz}}}\n\n\n\n\n------------------------------------------------------------------------------\n\n\n\nfor i, v in ipairs(text3D) do\n    p = {}\n    t = v\n    for i2, v2 in ipairs(t) do\n        vx,vy,vz = v2[1] + adjustorPos[1], 0 + adjustorPos[2], -v2[2] + adjustorPos[3]\n        x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n        y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n        z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n        p[#p+1] = {x=x,y=y,z=z}\n    end\n    text3DWorldPos[i] = p\nend\n\n\nlocal adjUp = core.getElementUpById(adjustor1ID) -- translation of adjustor local coords in world coords\nlocal adjX, adjY, adjZ = 0, 0, 0\nvx,vy,vz = adjUp[1], adjUp[2], adjUp[3]\nx = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\ny = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\nz = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\nadjX, adjY, adjZ = x, y, z\n\n\n--axis\nfor i, v in pairs(adjAxis3d) do\n    p = {}\n    t = v\n    for i2, v2 in ipairs(t) do\n        vx,vy,vz = v2[1] , v2[2] , v2[3] \n        x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n        y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n        z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n        p[#p+1] = {x=x,y=y,z=z}\n    end\n    axis3DWorldPos[i] = p\nend\n\n\n--textFraming\nfor i, v in pairs(textFraming) do\n    p = {}\n    t = v\n    for i2, v2 in ipairs(t) do\n        vx,vy,vz = v2[1] + adjustorPos[1], 0 + adjustorPos[2], -v2[2] + adjustorPos[3]\n        x = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\n        y = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\n        z = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\n        p[#p+1] = {x=x,y=y,z=z}\n    end\n    frame3DWorldPos[i] = p\nend\n\nvx,vy,vz = adjustorPos[1], adjustorPos[2], adjustorPos[3]\nx = vx * cWORx + vy * cWOFx + vz * cWOUx + cWPx\ny = vx * cWORy + vy * cWOFy + vz * cWOUy + cWPy\nz = vx * cWORz + vy * cWOFz + vz * cWOUz + cWPz\nadjustorPos = {x=x,y=y,z=z}\n\nlocal rx, ry, rz = 0, 0, 0\nfor i, v in ipairs(text3DWorldPos) do -- loop through inputText to adjust each letter rotation\n    for i2, v2 in ipairs(v) do\n        rx, ry, rz = rotateVec(v2.x-adjustorPos.x, v2.y-adjustorPos.y, v2.z-adjustorPos.z, \n                                adjRot, \n                                cWOUx, cWOUy, cWOUz)\n        text3DWorldPos[i][i2] = {x=rx+adjustorPos.x, y=ry+adjustorPos.y, z=rz+adjustorPos.z}\n    end\nend\n\nfor i, v in pairs(frame3DWorldPos) do -- loop through inputText to adjust each letter rotation\n    for i2, v2 in ipairs(v) do\n        rx, ry, rz = rotateVec(v2.x-adjustorPos.x, v2.y-adjustorPos.y, v2.z-adjustorPos.z, \n                                adjRot, \n                                cWOUx, cWOUy, cWOUz)\n        frame3DWorldPos[i][i2] = {x=rx+adjustorPos.x, y=ry+adjustorPos.y, z=rz+adjustorPos.z}\n    end\nend\n\nlocal mWPP = player.getWorldPosition()\nlocal mWPPx, mWPPy, mWPPz = mWPP[1], mWPP[2], mWPP[3]\nlocal function vectorLen(x,y,z)\n    return sqrt(x * x + y * y + z * z)\nend\nif vectorLen(adjustorPos.x-mWPPx,adjustorPos.y-mWPPy,adjustorPos.z-mWPPz)>5 then unit.exit()end","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"3"},{"code":"if currentPolygon ~= 0 then\n    textInputFunctions[currentPolygon]()\nend","filter":{"args":[{"value":"leftmouse"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"4"}],"methods":[],"events":[]}